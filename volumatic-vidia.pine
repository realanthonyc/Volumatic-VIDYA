// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © realanthonyc https://www.tradingview.com/u/realanthonyc

//@version=6
// ------------------------------------------------------------------
//  Volumatic VIDYA (Variable Index Dynamic Average) Optimized
//  On Github: https://github.com/realanthonyc/Volumatic-VIDYA
//  Forked from "Variable Index Dynamic Average" by BigBeluga
//  v1.9.0
// ------------------------------------------------------------------
indicator(title="Volumatic VIDYA Optimized", shorttitle="Vol-VIDYA", overlay=true, precision=2, max_lines_count=500, max_labels_count=500)

// === INPUTS ===

// Regular configuration for daily and higher timeframes
int vidya_length = input.int(10, 'VIDYA Length', group='Regular Configuration') // Length of the VIDYA calculation
int vidya_momentum = input.int(20, 'VIDYA Momentum', group='Regular Configuration') // Momentum length for VIDYA
float band_distance = input.float(2.00, 'Distance for VIDYA Lines', step=0.05, group='Regular Configuration') // Multiplier for ATR to set band distance

// Sensitivity configuration for lower timeframes
int vidya_length_s = input.int(3, 'VIDYA Length', group='Sensitivity Configuration')
int vidya_momentum_s = input.int(9, 'VIDYA Momentum', group='Sensitivity Configuration')
float band_distance_s = input.float(1.25, 'Distance for VIDYA Lines', step=0.05, group='Sensitivity Configuration')

// General settings
float source = input.source(close, 'Source', group='General Settings')
// Define pivot parameters
int pivot_bars = input.int(3, 'Pivot Bars', group='General Settings', tooltip='Number of bars on each side of the pivot used to confirm support/resistance.')
int pivot_left_bars = pivot_bars
int pivot_right_bars = pivot_bars
// Optimization: Max number of liquidity lines to keep to prevent memory bloat
int max_liquidity_lines = input.int(30, 'Max Liquidity Lines', minval=5, maxval=200, group='General Settings', tooltip='Maximum number of liquidity lines to avoid memory bloat.')
// Volume calculation options
string vol_calc_mode = input.string("Total Volume", "Volume Calculation Mode", options = ["Total Volume", "Average Volume"], group="General Settings", tooltip="Choose 'Total Volume' to sum the volume of the pivot bars, or 'Average Volume' to divide by the window size.")
bool show_vol_labels = input.bool(false, "Show Liquidity Volume Labels", group="General Settings", tooltip="Toggle the text labels showing volume size. Disable to save visual space.")

// Colors
color up_trend_color = input.color(#17dfad, 'Uptrend', group='Colors', inline='c')
color down_trend_color = input.color(#dd326b, 'Downtrend', group='Colors', inline='c')
bool shadow = input.bool(true, 'Enable Shadow', group='Colors')
int shadow_transparency = input.int(92, 'Shadow Transparency', minval=0, maxval=100, group='Colors')
color fill_gradient_end_color = input.color(color.rgb(255, 255, 255, 100), 'Fill Gradient End Color', group='Colors')
color volume_label_bg_color = input.color(color.rgb(255, 255, 255, 60), 'Volume Label', group='Colors')

// === INITIALIZATION ===

// Initialize variables for line, volume, and trend state
var line pivot_line = na // Variable for storing line references
float smoothed_value = na // Smoothing variable for VIDYA trend levels
var bool is_trend_up = false // Boolean variable for tracking trend direction

// Initialize arrays for storing line and volume information
var array<line> liquidity_lines_low = array.new<line>() // Array for storing lines for lows
var array<line> liquidity_lines_high = array.new<line>() // Array for storing lines for highs
var array<float> liquidity_volume_values_low = array.new<float>()
var array<float> liquidity_volume_values_high = array.new<float>()
var array<label> liquidity_volume_labels_low = array.new<label>()
var array<label> liquidity_volume_labels_high = array.new<label>()
var array<label> liquidity_marker_labels_low = array.new<label>()
var array<label> liquidity_marker_labels_high = array.new<label>()

// Initialize volume counters to 0.0 instead of na to prevent na propagation
var float up_trend_volume = 0.0
var float down_trend_volume = 0.0

// === FUNCTIONS ===

// Define VIDYA
vidya_calc(src, vidya_length, vidya_momentum) =>
    float momentum = ta.change(src)
    float sum_pos_momentum = math.sum(momentum >= 0 ? momentum : 0.0, vidya_momentum)
    float sum_neg_momentum = math.sum(momentum >= 0 ? 0.0 : -momentum, vidya_momentum)
    float abs_cmo = math.abs(100 * (sum_pos_momentum - sum_neg_momentum) / (sum_pos_momentum + sum_neg_momentum))
    float alpha = 2 / (vidya_length + 1)
    var float vidya_value = 0.0
    vidya_value := alpha * abs_cmo / 100 * src + (1 - alpha * abs_cmo / 100) * nz(vidya_value[1])
    ta.sma(vidya_value, 15)

// Method to safely push lines and limit array size
method safe_push(array<line> line_array, array<float> volume_array, array<label> volume_label_array, array<label> marker_label_array, line new_line, float new_volume) =>
    line_array.push(new_line)
    volume_array.push(new_volume)
    volume_label_array.push(na)
    marker_label_array.push(na)
    if line_array.size() > max_liquidity_lines
        line deleted_line = line_array.shift()
        line.delete(deleted_line)
        volume_array.shift()
        label removed_volume_label = volume_label_array.shift()
        if not na(removed_volume_label)
            label.delete(removed_volume_label)
        label removed_marker_label = marker_label_array.shift()
        if not na(removed_marker_label)
            label.delete(removed_marker_label)

// Method to extend lines and add labels for liquidity levels (single 'if' for loop)
method extend_liquidity_lines(array<line> line_array, array<float> volume_array, array<label> volume_label_array, array<label> marker_label_array, float price_level, bool is_cross, bool show_labels) =>
    // Only process lines within the last 5000 bars to optimize performance
    if line_array.size() > 0 and bar_index >= math.max(0, last_bar_index - 5000)
        int i = line_array.size() - 1
        while i >= 0
            line liquidity_line = line_array.get(i)
            float current_line_level = line.get_y2(liquidity_line)
            bool price_cross = is_cross ? price_level < current_line_level and price_level[1] >= current_line_level : price_level > current_line_level and price_level[1] <= current_line_level
            bool is_short_line = bar_index - line.get_x1(liquidity_line) < 50
            if price_cross and is_short_line
                line.set_x2(liquidity_line, bar_index)
                
                // Handle Markers (Dots) - Always update these
                label existing_marker_label = marker_label_array.get(i)
                if not na(existing_marker_label)
                    label.delete(existing_marker_label)
                label marker_label = label.new(bar_index - 1, price_level[1], text = '◉', color = color.rgb(0, 0, 0, 100), textcolor = is_cross ? down_trend_color : up_trend_color, style = label.style_label_center, size = size.normal)
                marker_label_array.set(i, marker_label)

                // Handle Volume Labels (Text) - Only run if checkbox is enabled
                label existing_volume_label = volume_label_array.get(i)
                if not na(existing_volume_label)
                    label.delete(existing_volume_label)
                if show_labels
                    float line_volume = volume_array.get(i)
                    // Add volume label to the liquidity zone
                    label volume_label = label.new(bar_index - 1, price_level[1], str.tostring(line_volume, format.volume), color = volume_label_bg_color, style = is_cross ? label.style_label_lower_left : label.style_label_upper_left, textcolor = chart.fg_color, size = size.small)
                    volume_label_array.set(i, volume_label)
            i -= 1

// === CALCULATIONS ===

// Calculate the Average True Range (ATR)
float atr_value = ta.atr(200)

// Switch to sensitive settings for not daily or higher timeframes
bool is_daily_or_higher = timeframe.isdaily or timeframe.isweekly or timeframe.ismonthly
bool use_sensitive_config = not is_daily_or_higher
int vidya_length_active = use_sensitive_config ? vidya_length_s : vidya_length
int vidya_momentum_active = use_sensitive_config ? vidya_momentum_s : vidya_momentum
float band_distance_active = use_sensitive_config ? band_distance_s : band_distance

// Calculate the VIDYA
float vidya_value = vidya_calc(source, vidya_length_active, vidya_momentum_active)

// Calculate upper and lower bands based on VIDYA and ATR
float upper_band = vidya_value + atr_value * band_distance_active
float lower_band = vidya_value - atr_value * band_distance_active

// Detect trend direction using crossovers of source with bands
if ta.crossover(source, upper_band)
    is_trend_up := true
if ta.crossunder(source, lower_band)
    is_trend_up := false

// Set trend-based smoothing variable
smoothed_value := is_trend_up ? lower_band : upper_band
smoothed_value := ta.change(is_trend_up) ? na : smoothed_value

// Calculate pivot highs and lows for price action
bool pivot_high = not na(ta.pivothigh(high, pivot_left_bars, pivot_right_bars)) // Use high for accurate resistance
bool pivot_low = not na(ta.pivotlow(low, pivot_left_bars, pivot_right_bars)) // Use low for accurate support

// Pre-calculate volume window and summed volume for consistency
int volume_window = math.max(1, pivot_right_bars + pivot_left_bars)
float summed_volume = math.sum(volume, volume_window)

// Calculate Volume based on user selection (Total or Average) - FIXED: Logic now matches input strings
float selected_volume_calc = vol_calc_mode == "Total Volume" ? summed_volume : (summed_volume / volume_window)
float pivot_volume = na(volume) or na(summed_volume) ? 0.0 : selected_volume_calc

// Assign volume. Bearish volume is now Positive, same as Bullish.
float avg_volume_up = pivot_volume
float avg_volume_down = pivot_volume 

// Create and store lines for pivot lows (support zones)
if low[pivot_right_bars] > smoothed_value and pivot_low
    pivot_line := line.new(bar_index[pivot_right_bars], low[pivot_right_bars], bar_index[pivot_right_bars] + 5, low[pivot_right_bars], color = color.new(up_trend_color, 50))
    line.set_style(pivot_line, line.style_dotted)
    liquidity_lines_low.safe_push(liquidity_volume_values_low, liquidity_volume_labels_low, liquidity_marker_labels_low, pivot_line, avg_volume_up)

// Create and store lines for pivot highs (resistance zones)
if high[pivot_right_bars] < smoothed_value and pivot_high
    pivot_line := line.new(bar_index[pivot_right_bars], high[pivot_right_bars], bar_index[pivot_right_bars] + 5, high[pivot_right_bars], color = color.new(down_trend_color, 50))
    line.set_style(pivot_line, line.style_dotted)
    liquidity_lines_high.safe_push(liquidity_volume_values_high, liquidity_volume_labels_high, liquidity_marker_labels_high, pivot_line, avg_volume_down)

// Extend lines to track price movements
liquidity_lines_high.extend_liquidity_lines(liquidity_volume_values_high, liquidity_volume_labels_high, liquidity_marker_labels_high, smoothed_value, true, show_vol_labels)
liquidity_lines_low.extend_liquidity_lines(liquidity_volume_values_low, liquidity_volume_labels_low, liquidity_marker_labels_low, smoothed_value, false, show_vol_labels)

// Detect and reset volume counters when trend changes, else accumulate volume
bool trend_changed = ta.change(is_trend_up)
if trend_changed
    up_trend_volume := 0.0
    down_trend_volume := 0.0
else if not na(volume)
    up_trend_volume += close > open ? volume : 0
    down_trend_volume += close < open ? volume : 0

// Average traded volume across both uptrend and downtrend bars
float avg_volume = math.avg(up_trend_volume, down_trend_volume)

// Determine the color of the trend
color trend_color = is_trend_up ? up_trend_color : down_trend_color

// Calculation of delta_volume — always show '0%' if avg is 0 or na
float volume_diff = up_trend_volume - down_trend_volume
string delta_volume = (na(avg_volume) or avg_volume == 0) ? '0%' : str.tostring((volume_diff / avg_volume) * 100, format.percent)

// === SHADOW ===
int fill_transparency = shadow ? shadow_transparency : 100

// === PLOT ===

// Display labels for volume and trend statistics on the last bar
if barstate.islast
    label.delete(label.new(bar_index, smoothed_value, 'Buy: ' + str.tostring(up_trend_volume, format.volume) + '\n Sell: ' + str.tostring(down_trend_volume, format.volume) + '\n Delta: ' + delta_volume, color = color.new(trend_color, 90), style = is_trend_up ? label.style_label_upper_left : label.style_label_lower_left, textcolor = chart.fg_color, size = size.small)[1])
    label.delete(label.new(bar_index, smoothed_value, text = '●', color = color.rgb(0, 0, 0, 100), textcolor = trend_color, style = label.style_label_center, size = size.small)[1])

// Plot the VIDYA trend line and HL2 reference line
p1 = plot(smoothed_value, color = color.new(trend_color, 15), style = plot.style_linebr, linewidth = 2, linestyle=plot.linestyle_dotted, title = 'VIDYA Trend Lines')
p2 = plot(hl2, color = color.new(trend_color, 30), linewidth = 2, display = display.none, title = 'HL2 Reference')

// Fill between VIDYA trend line and HL2 with gradient
fill(p1, p2, smoothed_value, hl2, color.new(trend_color, fill_transparency), fill_gradient_end_color)

// === ALERTS ===
// Alerts now fire only when the trend change is confirmed by the close of the next bar (second bar after flip)
alertcondition(ta.change(is_trend_up[1]) and is_trend_up[1], title='Trend Up (Confirmed)', message='{{ticker}}: VIDYA trend has changed to UP')
alertcondition(ta.change(is_trend_up[1]) and not is_trend_up[1], title='Trend Down (Confirmed)', message='{{ticker}}: VIDYA trend has changed to DOWN')
alertcondition(ta.change(is_trend_up[1]), title='Trend Changed (Confirmed)', message='{{ticker}}: VIDYA trend direction changed')